package com.github.ordom.remapper.mapping.tsrg

import com.github.ordom.remapper.VERSION
import net.fabricmc.mapping.reader.v2.TinyMetadata
import net.fabricmc.mapping.tree.*
import java.io.BufferedReader


private val TSRG2TINY_METADATA: TinyMetadata = object : TinyMetadata {
    override fun getMajorVersion() = 2
    override fun getMinorVersion() = 0
    override fun getNamespaces() = listOf("official", "srg")
    override fun getProperties(): MutableMap<String, String?> = mutableMapOf(
        "srg_version" to "tsrg2",
        "ordomal_version" to VERSION
    )
}

class TsrgReader(
    private val tsrg: BufferedReader
) {
    class TsrgTree: TinyTree {
        var from: String = ""
        var to: String = ""
        private val map: MutableMap<String, ClassDef> = mutableMapOf()
        private val classes: Collection<ClassDef>? = null
        override fun getMetadata(): TinyMetadata = TSRG2TINY_METADATA
        override fun getDefaultNamespaceClassMap(): MutableMap<String, ClassDef> {
            TODO("Not yet implemented")
        }

        override fun getClasses(): MutableCollection<ClassDef> {
            TODO("Not yet implemented")
        }
    }
    fun generateTiny(): TsrgTree {
        val tree = TsrgTree()
        // init
        run {
            val version = tsrg.untilBlank()
            if (version != "tsrg2") {
                throw IllegalArgumentException("Invalid TSRG version: $version, only supports tsrg2")
            }
            tree.from = tsrg.untilBlank()
            tree.to = tsrg.untilBlank()
            if (tsrg.untilBlank() != "id") {
                throw IllegalArgumentException("Invalid TSRG header, expected 'id'")
            }
        }
        // each line
        var lastIndent = 0
        var cls: ClassImpl? = null
        tsrg.lineSequence().forEachIndexed { index, line ->
            val indent = line.indent()
            if (indent > 0) {
                val parts = line.splitBlank()
                when {
                    parts.size == 1 && parts[0] == "static" -> return@forEachIndexed
                    // TSRG dose not contains a signature for fields, just use null.
                    parts.size == 3 -> cls!!.fields.add(FieldImpl(parts[0], parts[1], null))
                    parts.size == 4 && parts[1].startsWith('(') -> cls!!.methods.add(
                        MethodImpl(
                            parts[0],
                            parts[2],
                            parts[1]
                        )
                    )

                    parts.size == 4 && (parts[2].startsWith('p') /* parameter */
                            || parts[2].startsWith('f') /* record field */) -> {
                        // TODO: add parameter (no signature)
                    }

                    else -> throw IllegalArgumentException("Invalid TSRG line: $line (@line $index)")
                }
            }
            else {
                val parts = line.splitBlank()
                cls = ClassImpl(parts[0], parts[1])
            }
        }
        return tree
    }
    open class MappedImpl(
        obfuscated: String,
        srg: String
    ): Mapped {
        private val names: Array<String> = arrayOf(obfuscated, srg)
        override fun getName(namespace: String?) = names[TSRG2TINY_METADATA.index(namespace)]
        override fun getRawName(namespace: String?) = getName(namespace)
        override fun getComment() = "Generated by OrdomalRemapper v$VERSION"
    }
    class ClassImpl(obfuscated: String, srg: String): MappedImpl(obfuscated, srg), ClassDef {
        @JvmField
        internal val methods = mutableListOf<MethodDef>()
        @JvmField
        internal val fields = mutableListOf<FieldDef>()
        override fun getMethods(): MutableCollection<MethodDef> = methods
        override fun getFields(): MutableCollection<FieldDef> = fields
    }
    open class DescriptoredImpl(obfuscated: String, srg: String, private val obfuscatedSignature: String?): MappedImpl(obfuscated, srg), Descriptored {
        override fun getDescriptor(namespace: String?) = if (namespace == "official") obfuscatedSignature else obfuscatedSignature?.let {
            (it)
        }
    }
    class MethodImpl(obfuscated: String, srg: String, descriptor: String?):
        DescriptoredImpl(obfuscated, srg, descriptor), MethodDef {
        @JvmField
        internal val parameters = mutableListOf<ParameterDef>()
        @JvmField
        internal val localVariables = mutableListOf<LocalVariableDef>()
        override fun getParameters(): MutableCollection<ParameterDef> = parameters
        override fun getLocalVariables(): MutableCollection<LocalVariableDef> = localVariables
    }
    class FieldImpl(obfuscated: String, srg: String, descriptor: String?):
        DescriptoredImpl(obfuscated, srg, descriptor),
        FieldDef
    private fun String.indent(): Int {
        var i = 0
        while (i < length) {
            if (this[i] == '\t') i += 4
            else if (this[i] == ' ') i++
            else break
        }
        return i
    }
    private fun String.splitBlank(): List<String> {
        val list = mutableListOf<String>()
        var i = 0
        while (i < length) {
            val ch = this[i]
            if (ch == ' ' || ch == '\t') {
                i++
                continue
            }
            val start = i
            while (i < length) {
                val ch = this[i]
                if (ch == ' ' || ch == '\t') break
                i++
            }
            list.add(substring(start, i))
        }
        return list
    }
    private fun isBlank(ch: Int): Boolean {
        return ch == ' '.code || ch == '\n'.code || ch == '\t'.code
    }
    private fun BufferedReader.untilBlank(): String {
        val sb = StringBuilder()
        var ch = read()
        while (isBlank(ch) && ch != -1) {
            ch = read() // skip blanks
        }
        while (!isBlank(ch) && ch != -1) {
            sb.append(ch.toChar())
            ch = read()
        }
        return sb.toString()
    }
}